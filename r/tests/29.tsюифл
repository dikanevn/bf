import { Connection, Keypair, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, Transaction, TransactionInstruction } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, createMintToInstruction } from '@solana/spl-token';
import { expect } from 'chai';
import * as dotenv from 'dotenv';
import bs58 from 'bs58';

dotenv.config();

const TOKEN_METADATA_PROGRAM_ID = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
const MASTER_NFT_MINT = new PublicKey('5WMV8JsGVCmEwutjGeZucAfvkUwgFHrz5J5my6f2JLZD');

describe('Instruction 29', function() {
    this.timeout(30000);

    const connection = new Connection('https://api.devnet.solana.com', 'confirmed');
    const privateKeyString = process.env.PRIVATE_KEY!;
    const payer = Keypair.fromSecretKey(bs58.decode(privateKeyString));
    
    // Создаем новый минт для издания
    const newMint = Keypair.generate();

    it('should mint a token from existing NFT', async function() {
        console.log('Начинаем тест минтинга токена из существующего NFT (инструкция 29)');
        console.log('Адрес плательщика:', payer.publicKey.toBase58());
        console.log('Адрес нового минта:', newMint.publicKey.toBase58());
        console.log('Адрес мастер NFT:', MASTER_NFT_MINT.toBase58());

        // Получаем PDA для mint authority
        const [programAuthority] = PublicKey.findProgramAddressSync(
            [Buffer.from('mint_authority')],
            new PublicKey('YARH5uorBN1qRHXZNHMXnDsqg6hKrEQptPbg1eiQPeP')
        );

        // Получаем адрес метаданных мастер NFT
        const [masterMetadata] = PublicKey.findProgramAddressSync(
            [
                Buffer.from('metadata'),
                TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                MASTER_NFT_MINT.toBuffer(),
            ],
            TOKEN_METADATA_PROGRAM_ID
        );

        // Получаем адрес master edition
        const [masterEdition] = PublicKey.findProgramAddressSync(
            [
                Buffer.from('metadata'),
                TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                MASTER_NFT_MINT.toBuffer(),
                Buffer.from('edition'),
            ],
            TOKEN_METADATA_PROGRAM_ID
        );

        // Получаем адрес метаданных для нового издания
        const [editionMetadata] = PublicKey.findProgramAddressSync(
            [
                Buffer.from('metadata'),
                TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                newMint.publicKey.toBuffer(),
            ],
            TOKEN_METADATA_PROGRAM_ID
        );

        // Получаем адрес edition для нового издания
        const [edition] = PublicKey.findProgramAddressSync(
            [
                Buffer.from('metadata'),
                TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                newMint.publicKey.toBuffer(),
                Buffer.from('edition'),
            ],
            TOKEN_METADATA_PROGRAM_ID
        );

        // Получаем адрес edition mark PDA
        const editionNumber = 1; // Номер издания
        const editionMarkPda = PublicKey.findProgramAddressSync(
            [
                Buffer.from('metadata'),
                TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                MASTER_NFT_MINT.toBuffer(),
                Buffer.from('edition'),
                Buffer.from(editionNumber.toString()),
            ],
            TOKEN_METADATA_PROGRAM_ID
        )[0];

        // Получаем адрес токен аккаунта для мастер NFT
        const masterTokenAccount = await getAssociatedTokenAddress(
            MASTER_NFT_MINT,
            payer.publicKey
        );

        // Создаем буфер с номером издания
        const editionNumberBuffer = Buffer.alloc(8);
        editionNumberBuffer.writeBigUInt64LE(BigInt(editionNumber));

        const mintIx = new TransactionInstruction({
            programId: new PublicKey('YARH5uorBN1qRHXZNHMXnDsqg6hKrEQptPbg1eiQPeP'),
            keys: [
                { pubkey: editionMetadata, isSigner: false, isWritable: true },
                { pubkey: edition, isSigner: false, isWritable: true },
                { pubkey: masterEdition, isSigner: false, isWritable: true },
                { pubkey: newMint.publicKey, isSigner: false, isWritable: true },
                { pubkey: editionMarkPda, isSigner: false, isWritable: true },
                { pubkey: programAuthority, isSigner: false, isWritable: false },
                { pubkey: payer.publicKey, isSigner: true, isWritable: true },
                { pubkey: payer.publicKey, isSigner: true, isWritable: false },
                { pubkey: masterTokenAccount, isSigner: false, isWritable: false },
                { pubkey: programAuthority, isSigner: false, isWritable: false },
                { pubkey: masterMetadata, isSigner: false, isWritable: false },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                { pubkey: SYSVAR_INSTRUCTIONS_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ],
            data: Buffer.from([29, ...editionNumberBuffer])
        });

        const tx = new Transaction().add(mintIx);
        
        try {
            const signature = await connection.sendTransaction(tx, [payer]);
            await connection.confirmTransaction(signature);
            console.log('Транзакция успешно выполнена:', signature);
        } catch (error) {
            console.error('Ошибка при выполнении транзакции:', error);
            throw error;
        }
    });
}); 